
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // User-specific data (profile data, schedule, time tracking, milestones, study collections)
    match /users/{userId}/profile/{docId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    match /users/{userId}/schedule/{docId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    match /users/{userId}/timeTrackingState/{docId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    match /users/{userId}/timeTrackingLogs/{logId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    match /users/{userId}/milestones/{milestoneId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    match /users/{userId}/studyCollections/{collectionId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Notes with sharing
    match /users/{ownerId}/notes/{noteId} {
      // Owner can do anything
      allow create, delete, write: if request.auth != null && request.auth.uid == ownerId;
      // Read access:
      // 1. Owner can read.
      // 2. Authenticated user can read if their UID is in the note's `sharedWith` map with 'read' permission.
      allow read: if request.auth != null && (
                    request.auth.uid == ownerId ||
                    (resource.data.sharedWith[request.auth.uid] == 'read')
                  );
      // Ensure only owner can modify the sharedWith field or other critical fields during an update.
      // The general `write` rule above covers owner updates. If more granular control is needed on *what*
      // fields an owner can update vs. what a shared user with 'write' (future) permission could update,
      // separate update rules would be needed. For now, only owner can write/update.
    }


    // Study Rooms
    match /studyRooms/{roomId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.resource.data.createdBy == request.auth.uid;

      // Allow member list, member count, whiteboard, and updatedAt to be updated by any authenticated user who is a member or the creator
      allow update: if request.auth != null && (
                      (resource.data.createdBy == request.auth.uid) || // Creator can update anything
                      (request.resource.data.diff(resource.data).affectedKeys().hasAny(['members', 'memberCount', 'whiteboardDrawing', 'updatedAt']))
                    );
      allow delete: if request.auth != null && resource.data.createdBy == request.auth.uid;
    }

    // Study Room Messages
    match /studyRooms/{roomId}/messages/{messageId} {
      allow read: if request.auth != null && exists(/databases/$(database)/documents/studyRooms/$(roomId));
      allow create: if request.auth != null &&
                       ( (request.resource.data.userId == request.auth.uid) || 
                         (request.resource.data.userId == 'AI_ASSISTANT' && request.resource.data.userName == 'AI Helper') 
                       );
      // User can update their own (non-AI) messages. AI messages cannot be updated by users.
      allow update: if request.auth != null && resource.data.userId == request.auth.uid && resource.data.userId != 'AI_ASSISTANT';
      // User can delete their own (non-AI) messages. AI messages cannot be deleted by users.
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid && resource.data.userId != 'AI_ASSISTANT';
    }

    // System Agents (e.g., AI Helper Profile)
    match /systemAgents/{agentId} {
        allow read: if request.auth != null;
        allow write: if request.auth != null && agentId == 'AI_ASSISTANT_MAIN'; // Only allow admin-like write to specific AI profile
    }
  }
}
